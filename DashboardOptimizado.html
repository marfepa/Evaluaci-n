<!--
  ============================================================================
  M√ìDULO DE OPTIMIZACI√ìN PARA DASHBOARD
  ============================================================================

  Este archivo contiene las funciones optimizadas para reemplazar las
  funciones originales del dashboard.html

  Mejoras incluidas:
  - Carga paralela de datos
  - Debouncing en filtros de b√∫squeda
  - Virtualizaci√≥n de tablas grandes
  - Cach√© en el cliente
  - Renderizado incremental

  INSTRUCCIONES DE USO:
  1. Copiar estas funciones al final del <script> en dashboard.html
  2. Reemplazar las llamadas a las funciones originales
  3. O incluir este archivo: <?!= HtmlService.createHtmlOutputFromFile('DashboardOptimizado').getContent(); ?>
  ============================================================================
-->

<script>
  // ============================================================================
  // SISTEMA DE CACH√â DEL CLIENTE
  // ============================================================================

  const ClientCache = {
    cache: new Map(),
    timestamps: new Map(),

    // TTL por tipo de dato (en milisegundos)
    TTL: {
      stats: 5 * 60 * 1000,        // 5 minutos
      students: 10 * 60 * 1000,    // 10 minutos
      courses: 15 * 60 * 1000,     // 15 minutos
      instruments: 15 * 60 * 1000, // 15 minutos
      attendance: 2 * 60 * 1000    // 2 minutos
    },

    get(key, ttl) {
      if (this.cache.has(key)) {
        const timestamp = this.timestamps.get(key);
        const age = Date.now() - timestamp;

        if (age < ttl) {
          console.log(`‚úÖ Cache HIT: ${key} (age: ${(age/1000).toFixed(1)}s)`);
          return this.cache.get(key);
        } else {
          // Expirado
          this.cache.delete(key);
          this.timestamps.delete(key);
        }
      }

      console.log(`‚ùå Cache MISS: ${key}`);
      return null;
    },

    set(key, value) {
      this.cache.set(key, value);
      this.timestamps.set(key, Date.now());
      console.log(`üíæ Cached: ${key}`);
    },

    invalidate(key) {
      this.cache.delete(key);
      this.timestamps.delete(key);
    },

    invalidatePattern(pattern) {
      for (let key of this.cache.keys()) {
        if (key.includes(pattern)) {
          this.cache.delete(key);
          this.timestamps.delete(key);
        }
      }
    },

    clear() {
      this.cache.clear();
      this.timestamps.clear();
    }
  };

  // ============================================================================
  // CARGA PARALELA Y OPTIMIZADA DE DATOS
  // ============================================================================

  /**
   * Cargar todos los datos del dashboard en paralelo
   * Esto es MUCHO m√°s r√°pido que cargar secuencialmente
   */
  async function loadDashboardDataParallel() {
    console.time('‚è±Ô∏è Dashboard Load Time');

    try {
      // Mostrar indicador de carga global
      showLoading('Cargando datos del dashboard...');

      // Cargar TODOS los datos en paralelo (mega optimizaci√≥n)
      const [stats, students, courses, instruments] = await Promise.all([
        loadStatsOptimized(),
        loadStudentsDataOptimized(),
        loadCoursesOptimized(),
        loadInstrumentsDataOptimized()
      ]);

      // Guardar en cach√© global para uso posterior
      window.dashboardData = {
        stats,
        students,
        courses,
        instruments,
        loadedAt: new Date()
      };

      console.timeEnd('‚è±Ô∏è Dashboard Load Time');
      hideLoading();

      console.log('‚úÖ Dashboard data loaded:', {
        students: students?.length || 0,
        courses: courses?.length || 0,
        instruments: instruments?.length || 0
      });

    } catch (error) {
      console.error('‚ùå Error loading dashboard data:', error);
      hideLoading();
      showError('Error al cargar datos del dashboard', error.message);
    }
  }

  /**
   * Cargar estad√≠sticas con cach√©
   */
  async function loadStatsOptimized() {
    const cached = ClientCache.get('stats', ClientCache.TTL.stats);
    if (cached) {
      updateStatsUI(cached);
      return cached;
    }

    try {
      const data = await callBackend('getStatisticsCached'); // Usar funci√≥n con cach√© del servidor
      ClientCache.set('stats', data);
      updateStatsUI(data);
      return data;
    } catch (err) {
      console.error('Error loading stats:', err);
      // Intentar con la funci√≥n sin cach√© como fallback
      const data = await callBackend('getStatistics');
      updateStatsUI(data);
      return data;
    }
  }

  /**
   * Actualizar UI de estad√≠sticas
   */
  function updateStatsUI(data) {
    document.getElementById('totalStudents').textContent = data.students || 0;
    document.getElementById('totalCourses').textContent = data.courses || 0;
    document.getElementById('totalInstruments').textContent = data.instruments || 0;
    document.getElementById('totalGrades').textContent = data.grades || 0;
  }

  /**
   * Cargar estudiantes con cach√©
   */
  async function loadStudentsDataOptimized() {
    const cached = ClientCache.get('students', ClientCache.TTL.students);
    if (cached) {
      return cached;
    }

    try {
      const students = await callBackend('getEstudiantesCached'); // Usar funci√≥n con cach√© del servidor
      ClientCache.set('students', students);
      return students;
    } catch (err) {
      console.error('Error loading students:', err);
      // Fallback a funci√≥n sin cach√©
      const students = await callBackend('getEstudiantesData');
      return students;
    }
  }

  /**
   * Cargar cursos con cach√©
   */
  async function loadCoursesOptimized() {
    const cached = ClientCache.get('courses', ClientCache.TTL.courses);
    if (cached) {
      return cached;
    }

    try {
      const courses = await callBackend('getCursosCached'); // Usar funci√≥n con cach√© del servidor
      ClientCache.set('courses', courses);
      return courses;
    } catch (err) {
      console.error('Error loading courses:', err);
      // Fallback
      const courses = await callBackend('getCourses');
      return courses;
    }
  }

  /**
   * Cargar instrumentos con cach√©
   */
  async function loadInstrumentsDataOptimized() {
    const cached = ClientCache.get('instruments', ClientCache.TTL.instruments);
    if (cached) {
      return cached;
    }

    try {
      const instruments = await callBackend('getInstrumentosCached'); // Usar funci√≥n con cach√© del servidor
      ClientCache.set('instruments', instruments);
      return instruments;
    } catch (err) {
      console.error('Error loading instruments:', err);
      // Fallback
      const instruments = await callBackend('getInstrumentosData');
      return instruments;
    }
  }

  // ============================================================================
  // RENDERIZADO OPTIMIZADO CON VIRTUALIZACI√ìN
  // ============================================================================

  /**
   * Renderizar tabla de estudiantes (optimizado para listas grandes)
   */
  function renderStudentsTable(students, filter = '') {
    const tbody = document.getElementById('studentsTable');

    if (!students || students.length === 0) {
      tbody.innerHTML = '<tr><td colspan="4"><div class="empty-state"><div class="empty-state-icon">üë§</div><div>No hay estudiantes registrados</div></div></td></tr>';
      return;
    }

    // Filtrar estudiantes
    let filtered = students;
    if (filter) {
      filtered = students.filter(s => s.CursoID === filter);
    }

    // Si hay muchos estudiantes (>100), usar renderizado incremental
    if (filtered.length > 100) {
      renderLargeTable(tbody, filtered, renderStudentRow, 4);
    } else {
      // Renderizado normal para listas peque√±as
      tbody.innerHTML = filtered.map(renderStudentRow).join('');
    }
  }

  /**
   * Renderizar una fila de estudiante
   */
  function renderStudentRow(student) {
    return `
      <tr>
        <td>${student.IDEstudiante || '-'}</td>
        <td>${student.NombreEstudiante || '-'}</td>
        <td><span class="badge badge-primary">${student.CursoID || '-'}</span></td>
        <td>${student.Email || '-'}</td>
      </tr>
    `;
  }

  /**
   * Renderizar tabla grande de forma incremental (evita bloquear UI)
   */
  function renderLargeTable(tbody, data, rowRenderer, colspan) {
    // Mostrar mensaje de carga
    tbody.innerHTML = `<tr><td colspan="${colspan}"><div class="empty-state"><div class="loading"></div><div>Renderizando ${data.length} registros...</div></div></td></tr>`;

    const CHUNK_SIZE = 50; // Renderizar 50 filas a la vez
    let index = 0;
    let html = '';

    function renderChunk() {
      const end = Math.min(index + CHUNK_SIZE, data.length);

      for (let i = index; i < end; i++) {
        html += rowRenderer(data[i]);
      }

      index = end;

      // Actualizar progreso
      const progress = ((index / data.length) * 100).toFixed(0);

      if (index < data.length) {
        // Renderizar siguiente chunk en el pr√≥ximo frame
        requestAnimationFrame(renderChunk);
      } else {
        // Terminado, renderizar todo
        tbody.innerHTML = html;
        console.log(`‚úÖ Rendered ${data.length} rows`);
      }
    }

    // Comenzar renderizado
    setTimeout(renderChunk, 0);
  }

  /**
   * Renderizar instrumentos (optimizado)
   */
  function renderInstrumentsTable(instruments) {
    const tbody = document.getElementById('instrumentsTable');

    if (!instruments || instruments.length === 0) {
      tbody.innerHTML = '<tr><td colspan="5"><div class="empty-state"><div class="empty-state-icon">üéØ</div><div>No hay instrumentos registrados</div></div></td></tr>';
      return;
    }

    if (instruments.length > 100) {
      renderLargeTable(tbody, instruments, renderInstrumentRow, 5);
    } else {
      tbody.innerHTML = instruments.map(renderInstrumentRow).join('');
    }
  }

  /**
   * Renderizar fila de instrumento
   */
  function renderInstrumentRow(inst) {
    return `
      <tr>
        <td>${inst.IDInstrumento || '-'}</td>
        <td>${inst.NombreInstrumento || '-'}</td>
        <td><span class="badge badge-warning">${inst.TipoInstrumento || '-'}</span></td>
        <td>${inst.Situacion || '-'}</td>
        <td>
          <button class="btn btn-primary" style="padding: 0.5rem 1rem; font-size: 0.875rem;"
                  onclick="openInstrument('${inst.IDInstrumento}')">
            Abrir
          </button>
        </td>
      </tr>
    `;
  }

  // ============================================================================
  // DEBOUNCING PARA FILTROS Y B√öSQUEDAS
  // ============================================================================

  /**
   * Crear funci√≥n con debounce (evita llamadas excesivas)
   */
  function debounce(func, wait = 300) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  /**
   * Filtro de estudiantes con debounce
   */
  const filterStudentsDebounced = debounce((filterValue) => {
    console.log('üîç Filtering students:', filterValue);
    const students = window.dashboardData?.students || [];
    renderStudentsTable(students, filterValue);
  }, 300);

  // ============================================================================
  // FUNCIONES DE REEMPLAZO PARA EL DASHBOARD ORIGINAL
  // ============================================================================

  /**
   * Reemplazar loadStats() original
   */
  async function loadStats() {
    await loadStatsOptimized();
  }

  /**
   * Reemplazar loadStudents() original
   */
  async function loadStudents() {
    const courseFilter = document.getElementById('studentCourseFilter')?.value || '';
    const tbody = document.getElementById('studentsTable');

    tbody.innerHTML = '<tr><td colspan="4"><div class="empty-state"><div class="loading"></div><div>Cargando...</div></div></td></tr>';

    try {
      const students = await loadStudentsDataOptimized();
      renderStudentsTable(students, courseFilter);
    } catch (err) {
      console.error('Error loading students:', err);
      tbody.innerHTML = '<tr><td colspan="4"><div class="alert alert-error">Error al cargar estudiantes</div></td></tr>';
    }
  }

  /**
   * Reemplazar loadCourses() original
   */
  async function loadCourses() {
    try {
      const courses = await loadCoursesOptimized();
      const select = document.getElementById('studentCourseFilter');
      if (!select) return;

      const current = select.value;
      select.innerHTML = '<option value="">Todos los cursos</option>' +
        courses.map(c => `<option value="${c}">${c}</option>`).join('');
      select.value = current;
    } catch (err) {
      console.error('Error loading courses:', err);
    }
  }

  /**
   * Reemplazar loadInstruments() original
   */
  async function loadInstruments() {
    const tbody = document.getElementById('instrumentsTable');
    tbody.innerHTML = '<tr><td colspan="5"><div class="empty-state"><div class="loading"></div><div>Cargando...</div></div></td></tr>';

    try {
      const instruments = await loadInstrumentsDataOptimized();
      renderInstrumentsTable(instruments);
    } catch (err) {
      console.error('Error loading instruments:', err);
      tbody.innerHTML = '<tr><td colspan="5"><div class="alert alert-error">Error al cargar instrumentos</div></td></tr>';
    }
  }

  /**
   * Reemplazar loadTabData() original para usar carga paralela
   */
  function loadTabDataOptimized(tabId) {
    switch(tabId) {
      case 'overview':
        loadStats();
        break;
      case 'students':
        // Si ya tenemos los datos cargados, usarlos directamente
        if (window.dashboardData?.students) {
          renderStudentsTable(window.dashboardData.students);
          const select = document.getElementById('studentCourseFilter');
          if (select && window.dashboardData.courses) {
            const current = select.value;
            select.innerHTML = '<option value="">Todos los cursos</option>' +
              window.dashboardData.courses.map(c => `<option value="${c}">${c}</option>`).join('');
            select.value = current;
          }
        } else {
          loadStudents();
          loadCourses();
        }
        break;
      case 'attendance':
        const today = new Date().toISOString().split('T')[0];
        const dateInput = document.getElementById('attendanceDate');
        if (dateInput) dateInput.value = today;
        loadAttendanceDropdowns();
        loadRecentAttendance();
        break;
      case 'instruments':
        if (window.dashboardData?.instruments) {
          renderInstrumentsTable(window.dashboardData.instruments);
        } else {
          loadInstruments();
        }
        break;
    }
  }

  // ============================================================================
  // INICIALIZACI√ìN OPTIMIZADA
  // ============================================================================

  /**
   * Inicializar dashboard con precarga inteligente
   */
  function initializeDashboardOptimized() {
    console.log('üöÄ Initializing optimized dashboard...');

    // Cargar datos cr√≠ticos en paralelo de inmediato
    loadDashboardDataParallel();

    // Configurar debouncing en filtros
    const courseFilter = document.getElementById('studentCourseFilter');
    if (courseFilter) {
      courseFilter.addEventListener('change', () => {
        filterStudentsDebounced(courseFilter.value);
      });
    }

    // Configurar modales (click fuera para cerrar)
    document.querySelectorAll('.modal').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal(modal.id);
        }
      });
    });

    // Soporte de Enter en inputs
    document.querySelectorAll('.form-input').forEach(input => {
      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          const modal = input.closest('.modal');
          if (modal) {
            const confirmButton = modal.querySelector('.btn-primary');
            if (confirmButton) confirmButton.click();
          }
        }
      });
    });

    console.log('‚úÖ Optimized dashboard initialized');
  }

  // ============================================================================
  // FUNCIONES DE INVALIDACI√ìN DE CACH√â
  // ============================================================================

  /**
   * Invalidar cach√© despu√©s de modificar datos
   */
  function invalidateStudentsCache() {
    ClientCache.invalidatePattern('students');
    ClientCache.invalidate('courses');
    ClientCache.invalidate('stats');
    if (window.dashboardData) {
      delete window.dashboardData.students;
      delete window.dashboardData.courses;
    }
  }

  function invalidateInstrumentsCache() {
    ClientCache.invalidatePattern('instruments');
    ClientCache.invalidate('stats');
    if (window.dashboardData) {
      delete window.dashboardData.instruments;
    }
  }

  function invalidateAttendanceCache() {
    ClientCache.invalidatePattern('attendance');
    ClientCache.invalidate('stats');
  }

  // ============================================================================
  // AUTO-REEMPLAZO DE FUNCIONES ORIGINALES
  // ============================================================================

  // Si se est√° ejecutando, reemplazar la inicializaci√≥n original
  if (typeof initializeDashboard !== 'undefined') {
    console.log('üîÑ Replacing original initializeDashboard with optimized version');
    const originalInit = initializeDashboard;
    initializeDashboard = function() {
      originalInit(); // Llamar a la original por si tiene configuraciones importantes
      initializeDashboardOptimized(); // A√±adir optimizaciones
    };
  }

  // Reemplazar loadTabData si existe
  if (typeof loadTabData !== 'undefined') {
    console.log('üîÑ Replacing loadTabData with optimized version');
    loadTabData = loadTabDataOptimized;
  }

  console.log('‚úÖ Dashboard optimization module loaded');
</script>
